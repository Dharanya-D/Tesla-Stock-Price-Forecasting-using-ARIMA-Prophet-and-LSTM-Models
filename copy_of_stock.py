# -*- coding: utf-8 -*-
"""Copy of stock.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1sQ-R_rhRk7-Ahb_gjdOnv2hBilTI765j
"""

import pandas as pd
import numpy as np

from google.colab import files
uploaded = files.upload()

dataset = pd.read_csv('Tesla.csv.csv')

print(dataset.head())

print(dataset.tail())

print(dataset.shape)

print(dataset.info)

dataset.isnull().sum()

dataset.duplicated().sum()

dataset.describe()

dataset.describe(include='object')

dataset.dropna(inplace=True)

dataset['Date'] = pd.to_datetime(dataset['Date'])
dataset.set_index('Date', inplace=True)

import matplotlib.pyplot as plt

plt.figure(figsize=(14,6))
plt.plot(dataset['Close'], label='Closing Price')
plt.title('Tesla Stock Closing Price Over Time')
plt.xlabel('Date')
plt.ylabel('Price (USD)')
plt.legend()
plt.grid()
plt.show()

from statsmodels.tsa.seasonal import seasonal_decompose

result = seasonal_decompose(dataset['Close'], model='multiplicative', period=365)
result.plot()

from statsmodels.tsa.stattools import adfuller

result = adfuller(dataset['Close'])
print('ADF Statistic:', result[0])
print('p-value:', result[1])

data_diff = dataset['Close'].diff().dropna()

from statsmodels.tsa.arima.model import ARIMA

model = ARIMA(dataset['Close'], order=(5,1,0))  # (p,d,q)
model_fit = model.fit()
print(model_fit.summary())

# Step 1: Forecast the next 30 days
forecast_steps = 30
forecast = model_fit.forecast(steps=forecast_steps)

# Step 2: Plot actual + forecast
import matplotlib.pyplot as plt

plt.figure(figsize=(14,6))
plt.plot(dataset['Close'], label='Actual Closing Price')
plt.plot(forecast.index, forecast, label='Forecast (next 30 days)', color='red')
plt.title('ARIMA Forecast of Tesla Stock')
plt.xlabel('Date')
plt.ylabel('Price (USD)')
plt.legend()
plt.grid()
plt.show()

!pip install prophet

from prophet import Prophet
df = dataset.reset_index()[['Date', 'Close']]
df.columns = ['ds', 'y']

model = Prophet()
model.fit(df)

future = model.make_future_dataframe(periods=30)  # Forecast next 30 days
forecast = model.predict(future)

model.plot(forecast)
plt.title('Prophet Model Forecast (Tesla Stock)')
plt.xlabel('Date')
plt.ylabel('Price (USD)')
plt.grid()
plt.show()

model.plot_components(forecast)

!pip install tensorflow

import numpy as np
from sklearn.preprocessing import MinMaxScaler

scaler = MinMaxScaler(feature_range=(0,1))
scaled_data = scaler.fit_transform(dataset[['Close']])

def create_dataset(data, time_step=60):
    X, y = [], []
    for i in range(len(data) - time_step - 1):
        X.append(data[i:(i + time_step), 0])
        y.append(data[i + time_step, 0])
    return np.array(X), np.array(y)

time_step = 60
X, y = create_dataset(scaled_data, time_step)

# Reshape input for LSTM: [samples, time steps, features]
X = X.reshape(X.shape[0], X.shape[1], 1)

from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense

model = Sequential()
model.add(LSTM(50, return_sequences=True, input_shape=(time_step, 1)))
model.add(LSTM(50))
model.add(Dense(1))
model.compile(optimizer='adam', loss='mean_squared_error')

model.fit(X, y, epochs=10, batch_size=64, verbose=1)

train_predict = model.predict(X)
train_predict = scaler.inverse_transform(train_predict)
actual = scaler.inverse_transform(y.reshape(-1, 1))

plt.figure(figsize=(14,6))
plt.plot(actual, label='Actual')
plt.plot(train_predict, label='LSTM Prediction', color='orange')
plt.title('LSTM Model - Training Data Prediction')
plt.xlabel('Days')
plt.ylabel('Price (USD)')
plt.legend()
plt.grid()
plt.show()

from sklearn.metrics import mean_squared_error
import numpy as np

# Create test data for ARIMA
train_size = int(len(dataset['Close']) * 0.8)
train_arima = dataset['Close'][:train_size]
test_arima = dataset['Close'][train_size:]

# Fit model again on train data
from statsmodels.tsa.arima.model import ARIMA
model_arima = ARIMA(train_arima, order=(5,1,0))
model_arima_fit = model_arima.fit()

# Forecast same length as test
pred_arima = model_arima_fit.forecast(steps=len(test_arima))
rmse_arima = np.sqrt(mean_squared_error(test_arima, pred_arima))
print("ARIMA RMSE:", rmse_arima)

from prophet import Prophet

# Prepare prophet data
df = dataset.reset_index()[['Date', 'Close']]
df.columns = ['ds', 'y']
train_prophet = df.iloc[:train_size]
test_prophet = df.iloc[train_size:]

# Fit Prophet
model_prophet = Prophet()
model_prophet.fit(train_prophet)

# Forecast
future = model_prophet.make_future_dataframe(periods=len(test_prophet))
forecast = model_prophet.predict(future)

# Compare forecasted vs actual
pred_prophet = forecast['yhat'].iloc[-len(test_prophet):].values
rmse_prophet = np.sqrt(mean_squared_error(test_prophet['y'], pred_prophet))
print("Prophet RMSE:", rmse_prophet)

scaled_data = scaler.fit_transform(dataset[['Close']])

train_data = scaled_data[:train_size]
test_data = scaled_data[train_size - 60:]

X_train, y_train = create_dataset(train_data, 60)
X_test, y_test = create_dataset(test_data, 60)

X_train = X_train.reshape(X_train.shape[0], X_train.shape[1], 1)
X_test = X_test.reshape(X_test.shape[0], X_test.shape[1], 1)

model = Sequential()
model.add(LSTM(50, return_sequences=True, input_shape=(60, 1)))
model.add(LSTM(50))
model.add(Dense(1))
model.compile(optimizer='adam', loss='mean_squared_error')
model.fit(X_train, y_train, epochs=10, batch_size=64, verbose=1)

# Predict
lstm_pred = model.predict(X_test)
lstm_pred = scaler.inverse_transform(lstm_pred)
y_test_actual = scaler.inverse_transform(y_test.reshape(-1,1))

rmse_lstm = np.sqrt(mean_squared_error(y_test_actual, lstm_pred))
print("LSTM RMSE:", rmse_lstm)

models = ['ARIMA', 'Prophet', 'LSTM']
rmses = [rmse_arima, rmse_prophet, rmse_lstm]

plt.bar(models, rmses, color=['green', 'blue', 'orange'])
plt.title('RMSE Comparison of Models')
plt.ylabel('RMSE')
plt.show()

